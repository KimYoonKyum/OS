## 메모리 관리 전략
* 메모리에 로드된 프로세스를 효율적으로 관리하는 전략
* CPU는 레지스터를 참조하여 메모리 공간을 보호하며, 레지스터 정보는 PCB에 담겨있다. 이 때, 레지스터는 base와 limit으로 나뉜다. base는 메모리의 가장 작은 physical address이고, limit은 메모리의 가장 큰 physical address이다.
* Address Binding
  - 일반적으로 프로그램은 디스크에 Binary executable(이진실행가능한, 즉 이진파일)파일로 저장되어있다. 프로그램을 실행하기 위해서는 메모리에 로드해 프로세스로 만들어야한다.
  이때, 디스크에서 메인 메모리로 로드되기를 대기하는 곳이 input queue이다. OS는 Input queue에서 프로세스를 선택해 메모리를 로드한다.
  - 명령과 데이터를 메모리 주소로 binding 하는 시점에 binding이 구분된다.
    + complie time :  컴파일시 프로세스가 메모리 어느주소에 들어갈지 알고 있다면, absolute code를 생성, 만약 위치가 변경된다면 다시 컴파일 해야한다.
    + load time : 프로세스가 메모리 어느 위치에 들어갈지 미리 알 수 없다면, 컴파일러는 relocatable code를 만들어야함. 최대 로드의 소요시간만큼 걸림.
    + execution time: 프로세스가 실행 중 메모리의 한 세그먼트에서 다른 세그먼트로 이동할 수 있다면, binding은 runtime까지 지연.
* CPU가 생성하는 것은 Logical Address, 메모리에 의해 취급되는 주소는 Physical Address
* Swapping
  - 메모리는 크기가 크지 않기 때문에 프로세스를 임시로 디스크에 보냈다가 다시 메모리에 로드해야 되는 상황이 생긴다.  
    이렇게 메모리의 있는 프로세스를 디스크로 옮기거나, 디스크에 있는 프로세스를 다시 메모리에 로드 하는 것을 스와핑이라한다.  
    디스크로 내보내는 것을 swap out, 메모리로 들여보내는 것을 swap in이라고한다.  
    swap하는데 걸리는 시간은 대부분 디스크 전송시간이다.
  
## Contiguous Memory Allocation(연속적인 메모리 할당.)
* 프로세스를 메모리에 로드할 때는 먼저, 메모리 상에 프로세를 넣을 공간을 찾는다. 연속적인 메모리 할당은 말그대로 연속적인 공간의 메모리에 프로세스를 할당하는 것이다.
* 우선 메모리를 분할하는 단위는 block이고, 이 중에서 사용 가능한 block을 hole이라고 한다.
* 연속적인 메모리를 할당하는 방법
  - First Fit : 들어갈 메모리 중에 가장 처음 발견된 곳에 할당.
  - Best Fit : hole 중에서 제일 적정하게 들어갈 수 있는 공간을 할당.
  - Worst Fit : hole 중에서 제일 사이즈가 안맞는 공간(프로세스보다 큰)에 할당.

## Fragmentation(단편화)
* 단편화는 메모리 공간을 사용하지 못하게 되는 것을 말한다.

  
