## 페이지 교체
* 현재 프로그램이 실행되면서 요구하는 페이지가 늘어나게 되고, 메모리가 꽉찰 수 있게 된다. 그러면 다음 요구하는 페이지를 가져와  
메모리에 올릴 수 없게 되는데, 이때 특정 페이지를 내보내고 요구한 페이지를 메모리에 올리는데 이것을 페이지 교체라 한다.
## 페이지 교체 알고리즘
* OPT(Optimal Replacement, 최적교체)
  - 가장 사용하지 않을 페이지 교체, 미래 상황을 예측해야해서 실현가능성이 희박.
* FIFO(First In First Out)
  - 가장 먼저 올라온 페이지를 교체하는 것. 프레임 수가 많으면 page fault가 적게 일어나는 것이 일반적이지만,  
    프레임 수를 증가시켰는데도, page fault가 더 많이 일어나는 벨레이디의 모순 현상이 발생하게된다.
* LRU(Least Recently Used)
  - 최근에 가장 오랫동안 사용하지 않은 페이지 교체
* LFU(Least Frequency Used)
  - 사용 빈도가 가장 적은 페이지 교체
   
## 디스크 스케줄링
* 사용할 데이터가 디스크 상의 여러 곳에 저장되어 있을 경우, 디스크 헤드를 움직이는 최적의 경로를 결정하는 기법.
* FCFS(First Come First Service=FIFO)
  - 디스크 대기 큐에 가장 먼저 들어온 트랙 순서대로 디스크 헤드 이동시키는 방법.
  - 트랙이 분산되어 있으면 엄청난 비요율, 하지만 구현은 쉬운.
* SSTF(Shortest Seek Time First)
  - 현재 위치한 헤드에서 가장 가까운 트랙의 요청을 처리.
  - 평균 Seek Time이 짧긴 해도, 먼거리의 트랙을 가진 요청은 기아 상태가 발생할 수 있다.
* SCAN
  - 현재 헤드의 위치에서 진행방향이 결정되면, 탐색 거리가 짧은 순으로 진행 방향의 모든 요청을 처리하고,  
    다시 역방향으로 진행하면서 모든 요청을 처리.
  - SSTF 방법의 기아 상태를 해결할 수 있다.
  - 양쪽 끝 트랙은 가운데 위치한 트랙보다 대기 시간이 길어짐.
* C-SCAN(Circular Scan)
  - 헤드는 트랙의 바깥 쪽에서 안쪽으로 움직이면서, 가장 짧은 탐색거리 갖는 트랙 계속 처리.
  - 안쪽에 더이상의 요청이 없으면 헤드는 가장 바깥 쪽의 트랙으로 이동한 후 다시 안쪽으로 이동하면서 요청 처리.
* LOOK
  - 각 방향으로 가다가 그 방향에서 기다리는 요청이 없으면 그 즉시 방향을 바꾸어 탐색 시작.
* C-LOOK
  - C-SCAN 기법 기초로, 바깥에서 안쪽 모두 처리하고, 맨끝으로 가는 것이 아닌, 가장 바깥쪽 요청 트랙으로 가서 다시 안쪽으로 요청 수행.
